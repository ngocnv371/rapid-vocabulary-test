-- initialize Supabase tables (PostgreSQL) with RLS

-- profiles
CREATE TABLE IF NOT EXISTS public.profiles (
  id serial PRIMARY KEY, -- separate id from user_id on purpose
  user_id uuid not null references auth.users on delete cascade,
  name text,
  spirit text,
  zalo_id text,
  avatar_url text
);

ALTER TABLE IF EXISTS public.profiles ENABLE ROW LEVEL SECURITY;

-- Allow anyone to read all profiles (for leaderboard display)
CREATE POLICY "Allow public to read all profiles"
  ON public.profiles
  FOR SELECT
  TO public
  USING (true);

-- Allow users to insert their own profile (via trigger)
CREATE POLICY "Allow users to insert own profile"
  ON public.profiles
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- Allow users to update only their own profile
CREATE POLICY "Allow users to update own profile"
  ON public.profiles
  FOR UPDATE
  TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Allow users to delete their own profile
CREATE POLICY "Allow users to delete own profile"
  ON public.profiles
  FOR DELETE
  TO authenticated
  USING (auth.uid() = user_id);

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER set search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (user_id, name, spirit, avatar_url, zalo_id)
  VALUES (NEW.id, new.raw_user_meta_data->>'name', new.raw_user_meta_data->>'spirit', new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'zalo_id')
  ON CONFLICT (id) DO NOTHING;

  RETURN NEW;
END;
$$;


DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION public.handle_new_user();

-- categories
CREATE TABLE IF NOT EXISTS public.categories (
  id              TEXT PRIMARY KEY,
  name            TEXT NOT NULL UNIQUE,
  icon            TEXT
);
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public to read all categories" ON public.categories
  FOR SELECT
  TO public
  USING (true);

CREATE TABLE IF NOT EXISTS public.words (
  id              BIGSERIAL PRIMARY KEY,
  word            TEXT NOT NULL,
  category        TEXT NOT NULL REFERENCES public.categories(id) ON DELETE CASCADE,
  language        TEXT NOT NULL,
  meaning         TEXT NOT NULL
);
ALTER TABLE public.words ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public to read all words" ON public.words
  FOR SELECT
  TO public
  USING (true);

-- table scores for leaderboard
CREATE TABLE IF NOT EXISTS public.scores (
  id              BIGSERIAL PRIMARY KEY,
  profile_id      serial NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  category        TEXT NOT NULL REFERENCES public.categories(id) ON DELETE CASCADE,
  score           INT NOT NULL,
  created_at      timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE public.scores ENABLE ROW LEVEL SECURITY;

-- Allow public to read all scores (for leaderboard)
CREATE POLICY "Allow public to read all scores"
  ON public.scores
  FOR SELECT
  TO public
  USING (true);

-- Only non-anonymous authenticated users can insert scores
CREATE POLICY "Only permanent users can post scores"
  ON public.scores
  FOR INSERT
  TO authenticated
  WITH CHECK (
    (SELECT (auth.jwt()->>'is_anonymous')::boolean) IS FALSE
  );

-- Users can delete their own scores
CREATE POLICY "Allow users to delete own scores"
  ON public.scores
  FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.id = scores.profile_id
    )
  );

-- credits table to track user credits
CREATE TABLE IF NOT EXISTS public.credits (
  id              BIGSERIAL PRIMARY KEY,
  profile_id      serial NOT NULL UNIQUE REFERENCES public.profiles(id) ON DELETE CASCADE,
  amount          INT NOT NULL DEFAULT 0
);
ALTER TABLE public.credits ENABLE ROW LEVEL SECURITY;

-- Users can only view their own credits
CREATE POLICY "Users can view own credits"
  ON public.credits
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.id = credits.profile_id
    )
  );

-- Function to initialize credits for new profiles
CREATE OR REPLACE FUNCTION public.handle_new_profile()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER set search_path = ''
AS $$
BEGIN
  INSERT INTO public.credits (profile_id, amount)
  VALUES (NEW.id, 10);
  
  RETURN NEW;
END;
$$;

-- Trigger to create credits when a new profile is created
DROP TRIGGER IF EXISTS on_profile_created ON public.profiles;

CREATE TRIGGER on_profile_created
AFTER INSERT ON public.profiles
FOR EACH ROW
EXECUTE FUNCTION public.handle_new_profile();